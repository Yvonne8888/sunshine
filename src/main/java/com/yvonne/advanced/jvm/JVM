1. JVM数据类型 {
    1.1 基本类型 {
        1.1.1 数值类型 {
            整型：byte、short、int、long
            浮点型：float、double
            char型
        }
        1.1.2 boolean类型 {
            true、false
            注意：boolean类型的操作会被转化为int类型操作，boolean数组会当成byte数组操作，1位true，0为false。
        }
        1.1.3 returnAddress类型 {
            是一个指针，指向JVM指令的操作码，在Java中没有与之对应的类型
        }
    }
    1.2 引用类型 {
        1.2.1 类类型
        1.2.2 数组类型
        1.2.3 接口类型
    }
}

2. JVM内存模型 {
    2.1. 公有数据区 {
        2.1.1 堆 {
            堆内存是JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。
            所有的对象和数组都在堆上进行分配，这部分空间可通过 GC 进行回收，当申请不到空间时会抛出 OutOfMemoryError
        }
        2.1.2 方法区 {
            方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。
            方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”
        }
    }
    2.2 私有数据区 {
        2.2.1 pc寄存器 {
            也叫程序计数器，JVM支持多个线程同时运行，每个线程都有自己的程序计数器。
            倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；
            倘若执行的是native 方法，则PC寄存器中为空。
            唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，不需要进行GC
        }
        2.2.2 JVM栈 {
            虚拟机栈
            每个线程有一个私有的栈，随着线程的创建而创建，不需要进行GC。栈的大小可以固定也可以动态扩展。
            当栈调用深度大于JVM所允许的范围，会抛出StackOverflow的错误。
            *栈帧 {
                每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。
                当方法调用完成时，与之对应的栈帧会被销毁。
            }
        }
        2.2.3 native方法栈 {
            本地方法栈，这部分主要与虚拟机用到的native方法相关，不需要进行GC，一般情况下，Java应用程序员并不需要关心这部分的内容。
        }
    }
}

3. HotSpot虚拟机 {
    3.1 Java对象的内存分配过程是如何保证线程安全？
        HotSpot虚拟机优化方案：每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己预先内存中分配，当这块区域用完之后，
        再分配新的属于自己的内存。这种方案称之为TLAB分配（Thread Local Allocation Buffer线程本地分配缓冲区），在读取上为线程共享，
        但在内存分配上是线程独享。

}

4. 类加载机制 {
    4.1 类加载过程 {
        加载、连接（验证、准备、解析）、初始化
    }
}

5. 垃圾回收机制 {
    5.1 判断某些数据是否需要GC {
        5.1.1. 引用计数法（Reference Counting） {
            比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。
            垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。
            垃圾回收的起点是一些根对象（java栈, 静态变量, 寄存器...）。而最简单的Java栈就是Java程序执行的main函数。
        }
        5.1.2. 可达性算法 {
             可达性算法的原理是以一系列叫做  GC Root  的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，
             引出此节点指向的下一个结点。。。（这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意
             一个以 GC Root 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。
             对象就一定会被回收吗?并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，
             当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与
             GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！
             注意： finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，
             则会忽略 finalize 方法，对象会被回收！这一点切记!
        }
    }
    5.2 GC主要方法 {
        5.2.1 标记清除算法（Mark-Sweep） {
            此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。
            此算法需要暂停整个应用，同时，会产生内存碎片。
        }
        5.2.2 复制算法（Copying） {
             此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。
             次算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。
             当然，此算法的缺点也是很明显的，就是需要两倍内存空间。
        }
        5.2.3 标记整理法（Mark-Compact） {
            此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，
            第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。
            此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。
            但是缺点也很明显：每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下
        }
        5.2.4 分代收集算法（Generational Collecting） {
            基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、（Java8之前还有永久代），比例为1:2,对不同生命周期的对象使用不同的算法
            （上述方式中的一个）进行回收。
            现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的：{
                *为什么要分代 {
                    不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
                    在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，
                    这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，
                    比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。试想，在不进行对象存活时间
                    区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，
                    对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。
                    因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。
                }
                *如何分代 {
                    年轻代（Young） {
                        复制算法
                        所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。
                        一般年轻代分三个区：1个Eden区，2个Survivor区(from Survivor(S0)与to Survivor(S1)比例是8:1:1)。
                        大部分对象在Eden区中生成。当Eden区满时，触发Minor GC，还存活的对象将被复制到S0区（两个中的一个），
                        当这个S0区满时，此区的存活对象将被复制到另外一个S1区，当这个S1区也满了的时候，从S0区复制过来的并且此时还存活的对象，
                        将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制
                        过来的对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor区过来的对象。而且，
                        Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），
                        这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
                    }
                    年老代（Tenured） {
                        标记整理算法
                        在年轻代中达到设定阈值，就会被放到年老代中；当某个大对象分配需要大量的连续内存时，会直接分配到年老代；在Survivor区
                        相同年龄的对象大小之和大于Survivor空间一半以上时，也会分配到年老代。
                        因此，可以认为年老代中存放的都是一些生命周期较长的对象。
                        如果年老代满了，会触发Full GC，Full GC会同时回收年轻代和年老代（整个对），会导致Stop The Word（STW），
                        只有垃圾回收器线程在工作，其他工作线程则被挂起，造成大性能开销。
                        合适的时间触发GC，这个时间点被称为Safe Point，主要指一下特定位置 {
                            循环的末尾
                            方法返回前
                            调用方法的call之后
                            抛出异常的位置
                        }
                    }
                    永久代（Permanent） {
                        用于存放静态文件，如今Java类、方法等。永久代对垃圾回收没有显著影响，
                        但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。
                        永久代大小通过-XX:MaxPermSize=进行设置。
                        （JDK1.8中永久带被移除，由元数据区替换，元数据区不属于JVM内存模型，它属于系统内存）
                    }
                }
            }
        }
    }
    5.3 触发垃圾回收 {
        5.3.1 Minor GC {
            一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，
            并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。
            因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。
            因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。
        }
        5.3.2 Full GC {
            对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。
            在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：{
                · 年老代（Tenured）被写满
                · 永久代（Perm）被写满
                · System.gc()被显示调用
                · 上一次GC之后Heap的各域分配策略动态变化
            }
        }
    }
}