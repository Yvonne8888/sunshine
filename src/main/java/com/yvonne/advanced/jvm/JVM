1. JVM数据类型 {
    1.1 基本类型 {
        1.1.1 数值类型 {
            整型：byte、short、int、long
            浮点型：float、double
            char型
        }
        1.1.2 boolean类型 {
            true、false
            注意：boolean类型的操作会被转化为int类型操作，boolean数组会当成byte数组操作，1位true，0为false。
        }
        1.1.3 returnAddress类型 {
            是一个指针，指向JVM指令的操作码，在Java中没有与之对应的类型
        }
    }
    1.2 引用类型 {
        1.2.1 类类型
        1.2.2 数组类型
        1.2.3 接口类型
    }
}

2. JVM内存模型 {
    2.1. 公有数据区 {
        2.1.1 堆 {
            堆内存是JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。
            所有的对象和数组都在堆上进行分配，这部分空间可通过 GC 进行回收，当申请不到空间时会抛出 OutOfMemoryError
        }
        2.1.2 方法区 {
            方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。
            方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”
        }
    }
    2.2 私有数据区 {
        2.2.1 pc寄存器 {
            也叫程序计数器，JVM支持多个线程同时运行，每个线程都有自己的程序计数器。
            倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；
            倘若执行的是native 方法，则PC寄存器中为空。
        }
        2.2.2 JVM栈 {
            虚拟机栈
            每个线程有一个私有的栈，随着线程的创建而创建。栈的大小可以固定也可以动态扩展。
            当栈调用深度大于JVM所允许的范围，会抛出StackOverflow的错误。
            *栈帧 {
                每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。
                当方法调用完成时，与之对应的栈帧会被销毁。
            }
        }
        2.2.3 native方法栈 {
            本地方法栈，这部分主要与虚拟机用到的native方法相关，一般情况下，Java应用程序员并不需要关心这部分的内容。
        }
    }
}

3. HotSpot虚拟机 {
    3.1 Java对象的内存分配过程是如何保证线程安全？
        HotSpot虚拟机优化方案：每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己预先内存中分配，当这块区域用完之后，
        再分配新的属于自己的内存。这种方案称之为TLAB分配（Thread Local Allocation Buffer线程本地分配缓冲区），在读取上为线程共享，
        但在内存分配上是线程独享。

}

4. 类加载机制 {
    4.1 类加载过程 {
        加载、连接（验证、准备、解析）、初始化
    }
}

5. 垃圾回收机制 {
    GC收集方法 {

    }
}