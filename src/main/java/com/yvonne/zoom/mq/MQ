MQ消息队列
    使用的场景：
        1）异步：
            （非异步）用户提交交易->扣款->短信->积分->交易结束
                扣款成功后，再去发送短信，累计积分，此时整个RT(response time)变长
            （异步）用户提交交易->扣款->交易结束
                             ->短信
                             ->积分
                扣款成功后，短信和积分同时进行，此时整个RT缩短

            为什么不用线程？
                如果扣款成功后，除了短信，还需要做其它很多事情，使用线程的话，需要调用多个接口并且重新发布项目，而且排查也比较麻烦，耦合性比较高。
        2）削峰：
            当用户请求量大，服务器承受不了，这时候需要将请求放到队列中，至于每秒消费多少请求，得看服务器的处理能力，虽然比正常会慢一点，
                但是不至于宕机，等流量高峰下去，服务器也就没有压力
        3）解耦：
            用户提交交易->扣款->MQ->交易结束
                             ->短信
                             ->积分
                扣款成功后，将消息告诉别的系统，他们收到消息去处理，自己则继续走完流程。
                如果别的系统出现宕机导致短信或者积分失败，该怎么办？这时候就需要用到分布式事务

    缺点：
        1）系统复杂性：
            需要维护中间件
            使用的过程需要考虑比如说消息的重复消费、消息丢失、消息的顺序消费等
        2）数据一致性
            虽然提交交易，扣款的服务成功了，但是短信和积分无法保证百分百成功，保证数据一致性需要用到分布式事务，要么一起成功，要么一起失败
        3）可用性：
            万一MQ挂了，怎么办？

    常用MQ
        Kafka       ✔
        ActiveMQ
        RabbitMQ
        RocketMQ    ✔

    重复消费：
        用户提交交易->扣款->MQ->交易结束
                         ->短信
                         ->积分
        消息队列一般都有重试机制，如果下游业务发生异常，会抛出异常并且重发一次，这样子就会导致有些业务发了多次
        比如：两个业务都在监听，短信业务成功，积分业务失败，此时积分业务要求重发一次，但是短信就会发送两次
        （服务的网络抖动，开发人员的bug，数据问题等都有可能导致），那怎么处理呢？
            一般叫这样的处理为接口幂等（多次执行，结果都一样）
            分为强校验和弱校验。比如跟金钱相关的可以加强校验。
                强校验：比如监听到扣款成功的消息，监听到是否需要调用加积分接口，那加积分接口后再加一个加流水的接口，两个事务放在一起。
                    每次消息过来，都带着唯一标识去流水表中查，如果有这条流水，则return无需加积分和加流水。
                弱校验：比如发短信，唯一标识作为Redis的key，放到缓存里，一定时间内的这个消息就用redis判断。
    消息丢失：
    顺序消息：
    分布式事务：
        事务的四个属性ACID：
            1）原子性(atomicity)：一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。
            2）一致性(consistency)：事务必须是使数据库从一个一致性状态变到另外一个一致性状态，一致性与原子性密切相关。
            3）隔离性(isolation)：一个事务的执行不能被其他事务所干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，
                并发执行的各个事务之间是隔离的。
            4）持久性(durability)：也称永久性，值一个事务一旦提交，它对数据库中的数据的改变是永久性的，接下来的其他操作或故障应该对其有任何影响。
        2pc（两段式提交）:分布式的最开始，类似于媒婆，就是通过中间件协调多个系统，在两个系统操作事务的时候都锁定资源但不提交事务，等两者都已准备好，
            再告诉消息中间件，然后再分别提交事务，但是会有一个问题的产生，如果A系统提交事务成功，但是B系统由于网络抖动或者其他原因导致提交事务失败，
            该怎么，这个时候就要利用最终一致性。
        3pc（三段式提交）
        TCC（try confirm cancel）
        最大努力通知
        XA
        本地消息表
        半消息/最终一致性（RocketMQ）
            RocketMQ：高性能，高可靠，高实时，分布式等特点。

    RockedMQ:
        四大核心组成：
            NameServer：主要负责对于源数据的管理，包括了对于Topic和路由信息的管理
            Broker：消息中转角色，负责存储消息，转发消息
            Producer：消息生产者，负责产生消息，一般由业务系统负责产生消息
            Consumer：消息消费者，负责消费消息，一般是后台系统负责异步消费






